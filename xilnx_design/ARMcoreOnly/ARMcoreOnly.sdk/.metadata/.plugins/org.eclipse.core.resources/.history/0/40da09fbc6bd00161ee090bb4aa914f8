#include <stdio.h>
#include "platform.h"
#include <unistd.h>
#include "xtime_l.h"
#include <math.h>


void back_sub_4(double R[MAT_SIZE][MAT_SIZE], double * x, double *b);

void matrix_trans_vector_mult_4(double A_trans[MAT_SIZE][MAT_SIZE], double b[MAT_SIZE], double Ab[MAT_SIZE]);

void qr_decomp_4(double A[MAT_SIZE][MAT_SIZE], double Q[MAT_SIZE][MAT_SIZE], double R[MAT_SIZE][MAT_SIZE]);

int main()
{
	init_platform();
	unsigned long long tt[4];
	int tt_print[4];
	double Ab[MAT_SIZE];
	double x[MAT_SIZE];
	double R[MAT_SIZE][MAT_SIZE];
	double Q[MAT_SIZE][MAT_SIZE];
	XTime start_time_co;
	XTime stop_time_co;

    xil_printf("-- Start of the Program --\r\n");

	//FIRST MATRIX
    XTime_GetTime(&start_time_co);

	qr_decomp_4(A1, Q, R);
	matrix_trans_vector_mult_4(Q, b, Ab);
	back_sub_4(R, x, Ab);

	XTime_GetTime(&stop_time_co);


	tt[0] = stop_time_co - start_time_co;

	tt_print[0] = (unsigned) tt[0];

	xil_printf("Cycles to process first matrix: = %d \r\n", tt_print[0]);

	//SECOND MATRIX
	XTime_GetTime(&start_time_co);

	qr_decomp_4(A2, Q, R);
	matrix_trans_vector_mult_4(Q, b, Ab);
	back_sub_4(R, x, Ab);

	XTime_GetTime(&stop_time_co);


	tt[1] = stop_time_co - start_time_co;

	tt_print[1] = (unsigned) tt[1];

	xil_printf("Cycles to process second matrix: = %d \r\n", tt_print[1]);

	//Last MATRIX
	XTime_GetTime(&start_time_co);

	qr_decomp_4(A3, Q, R);
	matrix_trans_vector_mult_4(Q, b, Ab);
	back_sub_4(R, x, Ab);

	XTime_GetTime(&stop_time_co);


	tt[2] = stop_time_co - start_time_co;

	tt_print[2] = (unsigned) tt[2];

	xil_printf("Cycles to process final matrix: = %d \r\n", tt_print[2]);


	//ALL MATRICES AT ONCE
	XTime_GetTime(&start_time_co);
	qr_decomp_4(A1, Q, R);
	matrix_trans_vector_mult_4(Q, b, Ab);
	back_sub_4(R, x, Ab);
	qr_decomp_4(A2, Q, R);
	matrix_trans_vector_mult_4(Q, b, Ab);
	back_sub_4(R, x, Ab);
	qr_decomp_4(A3, Q, R);
	matrix_trans_vector_mult_4(Q, b, Ab);
	back_sub_4(R, x, Ab);
	XTime_GetTime(&stop_time_co);


	tt[3] = stop_time_co - start_time_co;

	tt_print[3] = (unsigned) tt[3];

	xil_printf("Cycles to process all thr matrices in a row: = %d \r\n", tt_print[3]);
	xil_printf("-- End of the Program --\r\n");


    return 0;
}

void back_sub_4(double R[MAT_SIZE][MAT_SIZE], double *x, double *b)
{
	x[MAT_SIZE-1] = b[MAT_SIZE-1] /R[MAT_SIZE-1][MAT_SIZE-1];

	x[MAT_SIZE-2] = (b[MAT_SIZE-2] - R[MAT_SIZE-2][MAT_SIZE-1] * x[MAT_SIZE-1]) / R[MAT_SIZE-2][MAT_SIZE-2];

	x[MAT_SIZE-3] = (b[MAT_SIZE-3] - R[MAT_SIZE-3][MAT_SIZE-1] * x[MAT_SIZE-1] - R[MAT_SIZE-3][MAT_SIZE-2] * x[MAT_SIZE-2]) / R[MAT_SIZE-3][MAT_SIZE-3];

	x[MAT_SIZE-4] = (b[MAT_SIZE-4] - R[MAT_SIZE-4][MAT_SIZE-1] * x[MAT_SIZE-1] - R[MAT_SIZE-4][MAT_SIZE-2] * x[MAT_SIZE-2]- R[MAT_SIZE-4][MAT_SIZE-3] * x[MAT_SIZE-3]) / R[MAT_SIZE-4][MAT_SIZE-4];
}



void matrix_trans_vector_mult_4(double A_trans[MAT_SIZE][MAT_SIZE], double b[MAT_SIZE], double Ab[MAT_SIZE])
{
	Ab[0] = A_trans[0][0] * b[0] + A_trans[1][0] * b[1] + A_trans[2][0] * b[2] + A_trans[3][0] * b[3];

	Ab[1] = A_trans[0][1] * b[0] + A_trans[1][1] * b[1] + A_trans[2][1] * b[2] + A_trans[3][1] * b[3];

	Ab[2] = A_trans[0][2] * b[0] + A_trans[1][2] * b[1] + A_trans[2][2] * b[2] + A_trans[3][2] * b[3];

	Ab[3] = A_trans[0][3] * b[0] + A_trans[1][3] * b[1] + A_trans[2][3] * b[2] + A_trans[3][3] * b[3];
}

static void vnorm(double *v, double * dst, int l)
{
	int i;
	double mag = 0.0;
	for(i = 0; i < l; i++)
	{
		mag += v[i] * v[i];
	}

	mag = sqrt(mag);

	for(i = 0; i < l; i++)
	{
		dst[i] = v[i] / mag;
	}
}

static double vdot(double v1[MAT_SIZE], double v2[MAT_SIZE])
{
	double sum = 0;
	int i;
	for(i = 0; i< MAT_SIZE; i++)
		sum += v1[i] * v2[i];
	return sum;
}

void qr_decomp_4(double A[MAT_SIZE][MAT_SIZE], double Q[MAT_SIZE][MAT_SIZE], double R[MAT_SIZE][MAT_SIZE])
{
	int i,j;
	double a[MAT_SIZE][MAT_SIZE], u[MAT_SIZE][MAT_SIZE], e[MAT_SIZE][MAT_SIZE];

	for(i = 0; i < MAT_SIZE; i++)
		for(j = 0; j < MAT_SIZE; j++)
			a[j][i] = A[i][j];

	vnorm(a[0], e[0], MAT_SIZE);

	for(i = 0; i < MAT_SIZE; i++)
		u[1][i] = a[1][i] - vdot(a[1], e[0])*e[0][i];
	vnorm(u[1], e[1], MAT_SIZE);

	for(i = 0; i < MAT_SIZE; i++)
		u[2][i] = a[2][i] - vdot(a[2], e[0])*e[0][i] - vdot(a[2], e[1])*e[1][i];
	vnorm(u[2], e[2], MAT_SIZE);

	for(i = 0; i < MAT_SIZE; i++)
		u[3][i] = a[3][i] - vdot(a[3], e[0])*e[0][i] - vdot(a[3], e[1])*e[1][i] - vdot(a[3], e[2])*e[2][i];
	vnorm(u[3], e[3], MAT_SIZE);

	for(i = 0; i< MAT_SIZE; i ++)
	{
		for(j = 0; j< MAT_SIZE; j++)
		{
			Q[i][j] = e[j][i];
			R[i][j] = (j < i) ? 0 : vdot(a[j], e[i]);
		}
	}
}
